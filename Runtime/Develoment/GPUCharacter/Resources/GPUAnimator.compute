#pragma kernel EvaluatePoses

struct AnimationMeta
{
    int startFrame;
    int numberOfFrames;
};

struct BoneRTS
{
    float4 pos;     // w = 0, not used
    float4 rot;     // Quaternion
    float4 scale;   // w = 0, not used
};

uniform int _NumBones;
StructuredBuffer<AnimationMeta> _AMetas;    // 1 per animation
StructuredBuffer<float> _FrameTimes;        // 1 per animation frame
StructuredBuffer<BoneRTS> _BoneRTSs;        // _NumBones * numberOfFrames per animation

uniform int _NumCharacters;
StructuredBuffer<int> _C2A;                 // 1 int per character, representing the animation being player by the character
StructuredBuffer<float> _C2T;               // 1 float per character, representing the point in the animation each character is in
RWStructuredBuffer<float4x4> _PoseMatrices; // _NumBones matrices per character
RWStructuredBuffer<BoneRTS> _PoseRTSs;

RWStructuredBuffer<float> _Debug;

// Groupshared memory
groupshared int nextFrame;
groupshared int prevFrame;
groupshared float frameLerp;

void ComputeFrameIndexes(AnimationMeta meta, float time, out int nextFrame, out int prevFrame, out float frameLerp)
{
    int start = meta.startFrame;
    int end   = start + meta.numberOfFrames - 1;

    while (start < end)
    {
        int mid = (start + end) >> 1; // computed mid point, bitshit equivalent to division since the value is int
        float midFrameTime = _FrameTimes[mid];
        if (midFrameTime < time) start = mid + 1;
        else end = mid;
    }

    // Computing prev frame from next frame
    nextFrame = start;
    prevFrame = nextFrame == meta.startFrame ? nextFrame : nextFrame - 1;
    float nextFrameTime = _FrameTimes[nextFrame];
    float prevFrameTime = _FrameTimes[prevFrame];

    // Converting to an index for _BonesRTSs
    nextFrame *= _NumBones;
    prevFrame *= _NumBones;

    // Computing lerp value
    frameLerp = nextFrame == meta.startFrame ? 0 : (time - prevFrameTime) / (nextFrameTime - prevFrameTime);
}

float4x4 QuatToMatrix(float4 q)
{
    float xx = q.x*q.x;
    float yy = q.y*q.y;
    float zz = q.z*q.z;
    float xy = q.x*q.y;
    float wz = q.w*q.z;
    float xz = q.x*q.z;
    float wy = q.w*q.y;
    float yz = q.y*q.z;
    float wx = q.w*q.x;
    return float4x4(
        1 - 2*(yy + zz),  2*(xy - wz),      2*(xz + wy),      0,
        2*(xy + wz),      1 - 2*(xx + zz),  2*(yz - wx),      0,
        2*(xz - wy),      2*(yz + wx),      1 - 2*(xx + yy),  0,
        0,                0,                0,                1
    ); 
}

float4x4 TransToMatrix(float3 t)
{
    return float4x4(
        1,  0,  0,  t.x,
        0,  1,  0,  t.z,
        0,  0,  1,  t.y,
        0,  0,  0,  1
    ); 
}

[numthreads(64,1,1)]
void EvaluatePoses(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    if(groupID.x == 0 && groupThreadID.x == 0) _Debug[0] = 1.25;

    int cID = groupID.x;
    // Only the first thread of the group computes the frame indexes and lerp value
    if(groupThreadID.x == 0)
    {
        AnimationMeta meta = _AMetas[_C2A[cID]];
        float time = _C2T[cID];
        ComputeFrameIndexes(meta, time, /*outs:*/ nextFrame, prevFrame, frameLerp);
    }
    GroupMemoryBarrierWithGroupSync();

    int boneID = groupThreadID.x;
    // if(boneID >= _NumBones) return;
    
    // Already accounts for _NumBones
    BoneRTS prevRTS = _BoneRTSs[prevFrame + boneID];
    BoneRTS nextRTS = _BoneRTSs[nextFrame + boneID];

    float3 pos = lerp(prevRTS.pos.xyz, nextRTS.pos.xyz, frameLerp);

    // Trying to debug
    // float4x4 boneMatrix = float4x4(
    //     1,      0,      0,      pos.x * 100,
    //     0,      1,      0,      pos.z * 100,
    //     0,      0,      1,      pos.y * 100,
    //     0,      0,      0,      1
    // );

    float4 r1 = prevRTS.rot;
    float4 r2 = nextRTS.rot;
    if (dot(r1, r2) < 0) r2 = -r2; // to avoid fliping
    float4 rot = normalize(lerp(r1, r2, frameLerp)); // nlerp


    float PI = 3.14159265359;
    float4 testRot = float4(0, sin(PI/4), 0, cos(PI/4)); // 90Â° around Y
    float4x4 boneMatrix = mul(TransToMatrix(pos), QuatToMatrix(rot));

    _PoseMatrices[cID * _NumBones + boneID] = boneMatrix;

    BoneRTS poseRTS;
    poseRTS.pos = float4(pos, 0);
    poseRTS.rot = rot;
    poseRTS.scale = float4(0,0,0,0);
    _PoseRTSs[cID * _NumBones + boneID] = poseRTS;

    // Leaving rotation and scale for later....

    // float3 scl = lerp(prevRTS.scale.xyz, nextRTS.scale.xyz, frameLerp);

    // float4 r1 = prevRTS.rot;
    // float4 r2 = nextRTS.rot;
    // if (dot(r1, r2) < 0) r2 = -r2; // to avoid fliping
    // float4 rot = normalize(lerp(r1, r2, frameLerp)); // nlerp

    // float y2 = rot.y*rot.y;
    // float4x4 rotationMatrix = float4x4(
    //     1 - 2*(rot.y*rot.y + rot.z*rot.z),  2*(rot.x*rot.y - rot.w*rot.z),      2*(rot.x*rot.z + rot.w*rot.y),      0,
    //     2*(rot.x*rot.y + rot.w*rot.z),      1 - 2*(rot.x*rot.x + rot.z*rot.z),  2*(rot.y*rot.z - rot.w*rot.x),      0,
    //     2*(rot.x*rot.z - rot.w*rot.y),      2*(rot.y*rot.z + rot.w*rot.x),      1 - 2*(rot.x*rot.x + rot.y*rot.y),  0,
    //     pos.x,                              pos.y,                              pos.z,                              1
    // );
    // float4x4 scaleMatrix = float4x4(
    //     scl.x, 0, 0, 0,
    //     0, scl.y, 0, 0,
    //     0, 0, scl.z, 0,
    //     0, 0, 0, 1
    // );
    // float4x4 boneMatrix = mul(rotationMatrix, scaleMatrix);
    // boneMatrix[3] = float4(pos, 1.0);
}