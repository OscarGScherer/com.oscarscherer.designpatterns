#pragma kernel EvaluatePoses

struct AnimationMeta
{
    int startFrame;
    int numberOfFrames;
};

struct BoneRTS
{
    float4 pos;     // w = 0, not used
    float4 rot;     // Quaternion
    float4 scale;   // w = 0, not used
};

uniform int _NumBones;
StructuredBuffer<AnimationMeta> _AMetas;    // 1 per animation
StructuredBuffer<float> _FrameTimes;        // 1 per animation frame
StructuredBuffer<BoneRTS> _BoneRTSs;        // _NumBones * numberOfFrames per animation

uniform int _NumCharacters;
StructuredBuffer<int> _C2A;                 // 1 int per character, representing the animation being player by the character
StructuredBuffer<float> _C2T;               // 1 float per character, representing the point in the animation each character is in
RWStructuredBuffer<float4x4> _PoseMatrices; // _NumBones matrices per character

RWStructuredBuffer<float> _Debug;

// Groupshared memory
groupshared int nextFrame;
groupshared int prevFrame;
groupshared float frameLerp;

void ComputeFrameIndexes(AnimationMeta meta, float time, out int nextFrame, out int prevFrame, out float frameLerp)
{
    int start = meta.startFrame;
    int end   = start + meta.numberOfFrames - 1;

    while (start < end)
    {
        int mid = (start + end) >> 1; // computed mid point, bitshit equivalent to division since the value is int
        float midFrameTime = _FrameTimes[mid];
        if (midFrameTime < time) start = mid + 1;
        else end = mid;
    }

    // Computing prev frame from next frame
    nextFrame = start;
    prevFrame = nextFrame == meta.startFrame ? nextFrame : nextFrame - 1;
    float nextFrameTime = _FrameTimes[nextFrame];
    float prevFrameTime = _FrameTimes[prevFrame];

    // Converting to an index for _BonesRTSs
    nextFrame *= _NumBones;
    prevFrame *= _NumBones;

    // Computing lerp value
    frameLerp = nextFrame == meta.startFrame ? 0 : (time - prevFrameTime) / (nextFrameTime - prevFrameTime);
}

float4x4 QuatToMatrix(float4 q)
{
    float xx = q.x*q.x;
    float yy = q.y*q.y;
    float zz = q.z*q.z;
    float xy = q.x*q.y;
    float wz = q.w*q.z;
    float xz = q.x*q.z;
    float wy = q.w*q.y;
    float yz = q.y*q.z;
    float wx = q.w*q.x;
    return float4x4(
        1 - 2*(yy + zz),  2*(xy - wz),      2*(xz + wy),      0,
        2*(xy + wz),      1 - 2*(xx + zz),  2*(yz - wx),      0,
        2*(xz - wy),      2*(yz + wx),      1 - 2*(xx + yy),  0,
        0,                0,                0,                1
    ); 
}

float4x4 TransToMatrix(float3 t)
{
    return float4x4(
        1,  0,  0,  t.x,
        0,  1,  0,  t.y,
        0,  0,  1,  t.z,
        0,  0,  0,  1
    ); 
}

float4x4 ScaleToMatrix(float3 s)
{
    return float4x4(
        s.x,  0,  0,  0,
        0,  s.y,  0,  0,
        0,  0,  s.z,  0,
        0,  0,  0,  1
    );
}

[numthreads(64,1,1)]
void EvaluatePoses(uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    if(groupID.x == 0 && groupThreadID.x == 0) _Debug[0] = 1.25;

    int cID = groupID.x;
    // Only the first thread of the group computes the frame indexes and lerp value
    if(groupThreadID.x == 0)
    {
        AnimationMeta meta = _AMetas[_C2A[cID]];
        float time = _C2T[cID];
        ComputeFrameIndexes(meta, time, /*outs:*/ nextFrame, prevFrame, frameLerp);
    }
    GroupMemoryBarrierWithGroupSync();

    int boneID = groupThreadID.x;
    if(boneID >= _NumBones) return;
    
    // Already accounts for _NumBones
    BoneRTS prevRTS = _BoneRTSs[prevFrame + boneID];
    BoneRTS nextRTS = _BoneRTSs[nextFrame + boneID];

    float3 pos = lerp(prevRTS.pos.xyz, nextRTS.pos.xyz, frameLerp);
    float3 scl = lerp(prevRTS.scale.xyz, nextRTS.scale.xyz, frameLerp);

    float4 r1 = prevRTS.rot;
    float4 r2 = nextRTS.rot;
    if (dot(r1, r2) < 0) r2 = -r2; // to avoid fliping
    float4 rot = normalize(lerp(r1, r2, frameLerp)); // nlerp


    float PI = 3.14159265359;
    float4 testRot = float4(0, sin(PI/4), 0, cos(PI/4)); // 90Â° around Y
    float4x4 boneMatrix = mul(QuatToMatrix(rot), ScaleToMatrix(scl));
    boneMatrix._m03_m13_m23 = TransToMatrix(pos)._m03_m13_m23;

    _PoseMatrices[cID * _NumBones + boneID] = boneMatrix;
}